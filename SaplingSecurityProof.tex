\def\notes{1}
\documentclass[11pt]{article}
%\usepackage[T1]{fontenc}
%\usepackage[letterpaper]{geometry}
%\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
%\usepackage{verbatim}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
%\usepackage{setspace}
\usepackage{xspace}%,enumitem}
%\usepackage{times}
\usepackage{fullpage}
%\usepackage{hyperref}
%\doublespacing
\usepackage{color}
\usepackage{mathrsfs}

%\usepackage{numdef}
%\usepackage{enumitem}
\usepackage{amsopn}
\usepackage{url,hyperref}  
\providecommand{\sqbinom}{\genfrac{\lbrack}{\rbrack}{0pt}{}}
\DeclareMathOperator{\spn}{span}

\newif\ifdraft
%\drafttrue
\drafttrue
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section} %% Comment out for sequentially-numbered
\numberwithin{figure}{section} %% Comment out for sequentially-numbered
\newtheorem{thm}{Theorem}[section]
\newtheorem{conjecture}[thm]{Conjecture}
\newtheorem{definition}[thm]{Definition}
\newtheorem{dfn}[thm]{Definition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{remark}[thm]{Remark}
\newtheorem{proposition}[thm]{Proposition}
\newtheorem{corollary}[thm]{Corollary}
\newtheorem{claim}[thm]{Claim}
\newtheorem{fact}[thm]{Fact}
\newtheorem{openprob}[thm]{Open Problem}
\newtheorem{remk}[thm]{Remark}
\newtheorem{example}[thm]{Example}
\newtheorem{apdxlemma}{Lemma}
\newcommand{\question}[1]{{\sf [#1]\marginpar{?}} }
%\usepackage{babel}
\usepackage{tikz}

\makeatletter
\newcommand*{\circled}{\@ifstar\circledstar\circlednostar}
\makeatother

\newcommand*\circledstar[1]{%
  \tikz[baseline=(C.base)]
    \node[%
      fill,
      circle,
      minimum size=1.35em,
      text=white,
      font=\sffamily,
      inner sep=0.5pt
    ](C) {#1};%
}
\newcommand*\circlednostar[1]{%
  \tikz[baseline=(C.base)]
    \node[%
      draw,
      circle,
      minimum size=1.35em,
      font=\sffamily,
      inner sep=0.5pt
    ](C) {#1};%
}

\providecommand{\bd}[1]{\circled{#1}}


%Eli's macros
\newcommand{\E}{{\mathbb{E}}}
%\newcommand{\N}{{\mathbb{N}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\calF}{{\cal{F}}}
\newcommand{\inp}{\ensuremath{\mathsf{inp}}\xspace}
\newcommand{\inps}{\ensuremath{\overrightarrow{\mathsf{inp}}}\xspace}
\newcommand{\outs}{\ensuremath{\overrightarrow{\mathsf{out}}}\xspace}
\newcommand{\out}{\ensuremath{\mathsf{out}}\xspace}
\newcommand{\disp}[1]{D_{#1}}
%\newcommand{\spn}[1]{{\rm{span}}\left(#1\right)}
%\newcommand{\supp}{{\rm{supp}}}
\newcommand{\agree}{{\sf{agree}}}
\newcommand{\RS}{{\sf{RS}}}
\newcommand{\aRS}{{\sf{aRS}}}
\newcommand{\rrs}{R_{\aRS}}
\newcommand{\VRS}{V_\RS}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand{\angles}[1]{\langle{#1}\rangle}
\newcommand{\condset}[2]{\set{#1 \mid #2 }}
\newcommand{\zo}{\set{0,1}}
\newcommand{\zon}{{\zo^n}}
\newcommand{\zom}{{\zo^m}}
\newcommand{\zok}{{\zo^}}
\newcommand{\eps}{\ensuremath{\epsilon}\xspace}
\newcommand{\e}{\eps}
%\newcommand{\d}{\delta}
\newcommand{\poly}{\ensuremath{\mathrm{poly}(\lambda)}\xspace}
\newcommand{\itone}{{\it{(i)}}\xspace}
\newcommand{\ittwo}{{\it{(ii)}}\xspace}
\newcommand{\itthree}{{\it{(iii)}}\xspace}
\newcommand{\itfour}{{\it{(iv)}}\xspace}
\newcommand{\cc}{{\rm{CC}}}
\newcommand{\rnk}{{\rm{rank}}}
\newcommand{\T}{T}
\newcommand{\I}{{\mathbb{I}}}
\ifdraft
\newcommand{\ariel}[1]{{\color{blue}{\textit{#1 --- ariel gabizon}}}}
\else
\newcommand{\ariel}[1]{}
\fi
\providecommand{\improvement}[1]{{\color{red} \textbf{#1}}}

\newcommand{\ate}[2]{\ensuremath{\mathsf{Ate_{opt}}(#1,#2)}\xspace}
\title{%
Sapling Security Proof}
\author{Ariel Gabizon \and Daira Hopwood}
\date{Zcash}
\begin{document}
\maketitle
 \mathchardef\mhyphen="2D

%\num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
%\num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{{\mathbb F}_r}\xspace}
\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}
\newcommand{\pubvalsOf}[1]{\ensuremath{\mathrm{pub}(#1)}\xspace}
\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{(#1)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\sigscheme}{\ensuremath{\mathscr S}\xspace}

\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}

\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2

\newcommand{\pos}{\ensuremath{\mathsf{pos}}\xspace}
\newcommand{\rej}{\ensuremath{\mathsf{rej}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\mathsf{comm}_{#1}}\xspace}
 \newcommand{\defeq}{:=}

%\renewcommand{\prime}[1]{\ensuremath{#1'}\xspace}
\newcommand{\inpwitness}{\ensuremath{\mathsf{inpwit}}\xspace}
\newcommand{\inpnote}{\ensuremath{\mathsf{inpnote}}\xspace}
\newcommand{\posnote}{\ensuremath{\mathsf{posnote}}\xspace}
\newcommand{\inpnotes}{\ensuremath{{\mathcal{I}}}\xspace}
\newcommand{\outnotes}{\ensuremath{{\mathcal{O}}}\xspace}
\newcommand{\outwitness}{\ensuremath{\mathsf{outwit}}\xspace}
\newcommand{\outnote}{\ensuremath{\mathsf{outnote}}\xspace}
\newcommand{\treehash}{\ensuremath{\mathsf{treehash}}\xspace}
\newcommand{\A}{\ensuremath{\vec{A}}\xspace}
\newcommand{\B}{\ensuremath{\vec{B}}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}

% \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
% \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
%\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
%\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace} 
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace} 
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}\xspace}
\newcommand{\Ftwo}{\ensuremath{\mathbb{F}_{p^2}}\xspace}
\newcommand{\Ftwlth}{\ensuremath{\mathbb{F}_{p^{12}}}\xspace}
\newcommand{\Ffour}{\ensuremath{\mathbb{F}_{p^4}}\xspace}
\newcommand{\Fsix}{\ensuremath{\mathbb{F}_{p^{6}}}\xspace}

\newcommand{\coinset}{\ensuremath{{\cal C}}\xspace}
\newcommand{\serialnumset}{\ensuremath{\mathrm{SN}}\xspace}
\newcommand{\addrset}{\ensuremath{{\cal A}}\xspace}
\newcommand{\txset}{\ensuremath{{\cal T}}\xspace}
\newcommand{\valueset}{\ensuremath{{\cal V}}\xspace}
\newcommand{\ledgers}{\ensuremath{{\cal L}}\xspace}
\newcommand{\gd}{\ensuremath{\mathsf{g}}\xspace}

\newcommand{\snof}[1]{\ensuremath{\mathrm{sn}(#1)}\xspace}
\newcommand{\nfof}[1]{\ensuremath{\mathsf{nf}(#1)}\xspace}
\newcommand{\rkof}[1]{\ensuremath{\mathsf{rk}(#1)}\xspace}
\newcommand{\valueof}[1]{\ensuremath{\mathrm{v}(#1)}\xspace}
\newcommand{\addrof}[1]{\ensuremath{\mathrm{addr}(#1)}\xspace}
\newcommand{\equals}[4]{\ensuremath{\mathsf{equals}(#1,#2,#3,#4)}\xspace}
\newcommand{\coins}{\ensuremath{\mathrm{\mathbf{c}}}\xspace}
\newcommand{\vold}{\ensuremath{\mathrm{v^{old}}}\xspace}
\newcommand{\vbal}{\ensuremath{\mathrm{v^{bal}}}\xspace}
\newcommand{\bal}{\ensuremath{\mathrm{bal}}\xspace}
\newcommand{\rand}{\ensuremath{\mathrm{\mathbf{rcv}}}\xspace}
\newcommand{\vnew}{\ensuremath{\mathrm{v^{new}}}\xspace}
\newcommand{\ledger}{\ensuremath{\mathrm{L}}\xspace}
\newcommand{\values}{\ensuremath{\mathrm{\mathbf{v}}}\xspace}
\newcommand{\valuesof}[1]{\ensuremath{\values(#1)}\xspace}
\newcommand{\addrs}{\ensuremath{\mathrm{\mathbf{a}}}\xspace}
\newcommand{\addrsof}[1]{\ensuremath{\addrs(#1)}\xspace}

\newcommand{\sqoftexset}{{\cal S}\xspace}
\newcommand{\verifytx}[2]{\ensuremath{\mathsf{verify\mhyphen tx} (#1,#2)}\xspace}
\newcommand{\serialnumbersof}[1]{\ensuremath{\mathrm{sn}(#1)}\xspace}
\newcommand{\coinsof}[1]{\ensuremath{\coins(#1)}\xspace}
\newcommand{\seqofcoins}{\ensuremath{\coins^*}\xspace}
\newcommand{\txinput}{\ensuremath{\mathrm{x}}\xspace}
\newcommand{\txinputs}{\ensuremath{\mathrm{\mathbf{x}}}\xspace}
\newcommand{\seqoftxset}{\ensuremath{\txset^*}\xspace}
\newcommand{\tx}{\ensuremath{\mathsf{tx}}\xspace}
\newcommand{\aprand}{\ensuremath{\mathrm{pp}}\xspace}
\newcommand{\coin}{\ensuremath{\mathrm{c}}\xspace}
\newcommand{\ledgerset}{\ensuremath{\mathcal{L}}\xspace}
\newcommand{\uniqueledgerset}{\ensuremath{\mathcal{L}^{\mathrm{unique}}}\xspace}
\newcommand{\serialnums}{\ensuremath{\mathrm{\mathbf{sn}}}\xspace}

\newcommand{\txinputset}{\ensuremath{\mathcal{I}}\xspace}

\newcommand{\createtx}[2]{\ensuremath{\mathsf{create\mhyphen tx}(#1,#2)}\xspace}
\newcommand{\decodebykey}[3]{\ensuremath{\mathsf{decode}_{#3}(#1,#2)}\xspace}%#3 is sk
\newcommand{\decode}[2]{\ensuremath{\mathsf{decode}(#1,#2)}\xspace}
   
\newcommand{\key}{\ensuremath{\mathrm{sk}}\xspace}
\newcommand{\keyof}[1]{\ensuremath{\key(#1)}\xspace}
\newcommand{\keyset}{\ensuremath{{\mathcal K}}\xspace}


\newcommand{\adv}{\ensuremath{{\mathcal A}}\xspace}
\newcommand{\advprime}{\ensuremath{{\mathcal A'}}\xspace}
\newcommand{\advs}{\ensuremath{{\mathcal{A}}}\xspace}
\newcommand{\advaddrs}{\ensuremath{\addrs_{\adv}}\xspace}
\newcommand{\coinsofserialnums}[2]{\ensuremath{\coins(#1,#2)}\xspace}
\newcommand{\seq}{\ensuremath{\mathsf{r}}\xspace}
\newcommand{\querseq}{\ensuremath{\mathsf{q}}\xspace}
\newcommand{\sigquerseq}{\ensuremath{\mathsf{q^\sigma}}\xspace}
\newcommand{\schnorr}{\ensuremath{\mathsf{Schnorr}}\xspace}
\newcommand{\rawof}[1]{\ensuremath{\mathsf{raw(#1)}}\xspace}
\newcommand{\honest}{\ensuremath{\mathcal H}\xspace}
\newcommand{\ext}{\ensuremath{\mathcal \xi}\xspace}
\newcommand{\G}{\ensuremath{\mathbb{G}}\xspace}
\newcommand{\sigseq}{\ensuremath{\mathsf{\sigma}}\xspace}
\newcommand{\sk}{\ensuremath{\mathsf{sk}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\sigquer}{\ensuremath{\mathsf{q^\sigma}}\xspace}
\newcommand{\RO}{\ensuremath{\mathcal R}\xspace}
\newcommand{\ROsig}{\ensuremath{\mathcal R_{sig}}\xspace}
\newcommand{\sig}{\ensuremath{\sigma}\xspace}
\newcommand{\sign}{\ensuremath{\mathsf{sign}}\xspace}
\newcommand{\versig}{\ensuremath{\mathsf{verifySig}}\xspace}
\renewcommand{\sim}{\ensuremath{ {\mathcal S}}\xspace}
\newcommand{\simprv}{\ensuremath{\sim_{\mathsf{sign}}}\xspace}
\newcommand{\simro}{\ensuremath{\sim_{\RO}}\xspace}
\newcommand{\str}{\ensuremath{\mathrm{x}}\xspace}
\newcommand{\negl}{\ensuremath{\mathrm{negl}(\lambda)}\xspace}
\newcommand{\msg}{\ensuremath{\mathbf m}\xspace}
\newcommand{\dist}{\ensuremath{\mathrm{\pi}}\xspace}
\newcommand{\oracle}{\ensuremath{\mathscr O}\xspace}
\newcommand{\oracleprime}{\ensuremath{\mathscr O'}\xspace}
\newcommand{\g}{\ensuremath{\mathsf{g}}\xspace}

\section{Signature schemes}
%We assume all parties below have access to a random oracle \RO taking arbitrary strings as input and outputting uniform elements of \F.

When we say an algorithm \adv is \emph{efficient}, when mean it runs in time \poly for the ``security parameter'' $\lambda$.


 \begin{dfn}\label{dfn:sigscheme}
Let \G be a group of prime order $r$.
A signature scheme \sigscheme over \G in the random oracle model consists of algorithms $\sigscheme = (\sign,\versig,\sim= (\simprv,\simro))$
where $\sign,\versig$ are oracle machines with access to an oracle \RO taking as input arbitrary strings and returning uniform elements of \F.
Such that the following holds.
 \begin{itemize}
  \item The set of public/verification keys \set{\pk} is \G, and the set of private keys \set{\sk} is \F.
  \item For $\sk \in \F$, the verification key of \sk is $\pk= \sk\cdot g$ for a fixed generator $g\in \G$.
  \item We have the following ``zero-knowledge'' property:
 Fix any efficient \adv.
 Suppose that \adv interacts with \sim with two types of queries 
  \begin{enumerate}
   \item Queries \str, for an arbitrary string \str that are answered according to $\simro$.
   \item Queries $(\pk,\msg)$, answered according to $\simprv$.
  \end{enumerate}
Let $\dist_1$ be the distribution of the sequence of queries and replies to \adv.
Let $\dist_2$ be the distribution of the sequence of queries and replies to \adv when

\begin{enumerate}
 \item \RO takes the place of  $\sim_1$
 \item $\sign^{\RO}(\sk,\msg)$ is returned instead of $\sim_2(\pk,\msg)$ where \sk is the secret key corresponding to \pk.
\end{enumerate}
Then the distance between $\dist_1$ and $\dist_2$ is \negl.
\end{itemize}

% 
% 
%  We say \sig is  \emph{simulation extractable with error $\eps$ over \G if:}
% 
%   There is an efficient \ext such that the following holds.  Fix any efficient \adv and consider the following process.
%   \adv askes a sequence of queries to \sim as described in the zero-knowledge property above.
%   Then \adv outputs $(\pk,\msg,\sig)$.
%   Then, \ext receives as input the queries of \adv to \sim and its responses, and the internal randomness used by \adv.
%   Now \ext, given access to rewinding and executing \adv as he wishes, outputs \sk.
%   Then the probability that
%   \begin{itemize}
%    \item $\versig^{\simro}(\pk,\msg,\sig)$, and
%    \item $\pk\neq \sk\cdot g$
%   \end{itemize}
% is at most $\eps$.
% 

%   We say \sig is \emph{randomizable extractable with error $\eps$ if:}
%   for any efficient \adv there is an efficient extractor \ext such that the following holds.
%   Suppose a party \honest somehow chooses $\ell= \poly$ keys $\sk_1,\ldots, \sk_\ell \in \F$ and
%   sends the verification keys $P=\set{\pk_1,\ldots,\pk_\ell}$ to \adv.
%   Then \adv is allowed to adaptively make \poly queries to \RO and to \honest.
%   The queries to \honest are of the form $(\pk,\rho,m)$ for $\pk\in P,\rho\in \F$,
%   and \honest replies with $\sign(\pk+\rho\cdot g, m)$.
%   Finally, \adv outputs $(\pk^*,\msg^*,\sig^*)$
%   Then, \ext receives as input the responses of \RO and \honest to \adv, and the internal randomness used by \adv,
%   and $\ext$, using access to \adv, outputs \sk.
%   Then the probability that 
%   \begin{enumerate}
%    \item $\versig(\pk^*,\msg^*,\sig^*)$, and 
%    \item $\sk\cdot g \neq \pk$
%    
%   \end{enumerate}
% is at most $\eps$

We say \sigscheme is \emph{unforgeable w.r.t key randomization} if the following holds.
Fix any efficient \adv.
A party \oracle chooses uniform $\sk\in \F$ and sends $\pk = \sk\cdot g$ to \adv.
\oracle also initializes an empty set $T$.
\adv adaptively makes \poly queries of the form $(\alpha,\msg)$.
\oracle replies with $\sig\defeq \sign(\pk+\alpha\cdot g, \msg)$
and adds $(\alpha,\msg,\sig)$ to $T$.

Finally \adv outputs $(\alpha^*,\msg^*,\sig^*)$.
Let $\pk^*\defeq \pk+\alpha^*\cdot g$.
 Then the probability that 
  \begin{enumerate}
   \item $\versig(\pk^*,\msg^*,\sig^*)$, and 
   \item $(\alpha^*,\msg^*,\sig^*)\notin T$
  \end{enumerate}
is \negl.
\end{dfn}

% \begin{claim}
% If \sigscheme is simulation extractable with error $\eps$ it is also randomizable extractable with error $\eps+\negl$.
% \end{claim}
% \begin{proof}
% Have adv \adv against RE.
% Define the following \adv' against SE:
% \begin{enumerate}
%  \item Start by choosing uniformly \set{\sk_1,\ldots,\sk_\ell} and 
%  sending \set{\pk_1,\ldots,\pk_\ell} to \adv.
%  \item When \adv asks a query to \RO, answer it according to \simro.
%  \item When \adv asks a query $(\pk,\rho,\msg)$ to \honest, answer it with $\simprv(\pk+\rho\cdot g,\msg)$
% \item When \adv outputs $(\pk^*,\msg^*,\sig^*)$, output the same message.
%  \end{enumerate}
% Let \ext' be the extractor guaranteed to exist for \adv'.
% Now construct \ext for \adv as follows.
% \adv is executed, and the \ext is given $P=\set{P_1,\ldots,P_\ell}$,\seq,\querseq,\sigseq,\sigquerseq
% and its output $(\pk^*,\msg^*,\sig^*)$.
% 
% 
% Note that (\adv')'s output is determined by the value
% Note that the except for a negligible fraction of the time \adv succeeds relative to $\versig^{\RO}$ at the same
% \adv' succeeds relative to $\versig^{\simro}$.
% So \ext' is also a good extractor for \adv demonstrating the scheme has the $\eps'$ ``randomized extractability'' property for 
% $\eps' = \eps +\negl$.
% \end{proof}
% 
% 
 
 
 
 
 We assume our group \G has a hard DL problem; meaning that for any efficient \adv,
 given uniform $g,\sk\cdot g \in \G$ the probability of outputting \sk is \negl.
 
 We define the non-malleable version of Schnorr's signature scheme:
 
\paragraph{\underline{\schnorr:}} 
 \paragraph{Parameters:}
 Group \G of prime order $s$. Non-zero $g\in \G$.
 \paragraph{Signing:}
  Given message \msg and \sk, 
 \begin{itemize}
 \item Choose random $a\in \F$ and let $R\defeq a\cdot g$

  \item Compute $c\defeq \RO(R,\pk,\msg)$
  \item Let $u\defeq a+c\cdot \sk$.
  \item Define $\sign^{\RO}(\sk,\msg) \defeq (R,u)$.
 \end{itemize}
\paragraph{Verifying:}
 Given $\pk,\msg,\sig=(R,u)$, $\versig^{\RO}(\pk,\msg,\sig)$ 
 accepts iff:

\begin{itemize}
 \item Computing $c\defeq \RO(R,\pk,\msg)$; we have $u\cdot g = R+c\cdot \pk$.
\end{itemize}
\paragraph{Simulating:}
\begin{itemize}
\item $\simro(\str)$ checks if \str has been queried before; if so answers consistently, otherwise answers uniformly in \F and records the answer. 
 \item $\simprv(\pk,\msg)$: Choose uniform $c,u \in \F$.
 Let $\str \defeq (\pk,\msg, u\cdot g - c\cdot \pk)$.
 Check if $\simro(\str)$ has been defined.
 If so, abort.  Otherwise define $\simro(\str)=c$ and return $(c,u)$.
\end{itemize}
\begin{remark}
 At times when we wish to change the parameter $g$ we work with from default to an element $h$,
 we will use it in the subscript, e.g. $sign_h^{\RO}(\sk,\msg)$.
 
 We refer by $\schnorr' = (\sign',\versig')$ to the Schnorr scheme where \pk is omitted from the computation of $c$.
\end{remark}
\begin{thm}\label{thm:schnorr-nf}
\schnorr is non-forgeable w.r.t randomization.
\end{thm}
\begin{proof}
Similarly to \cite{rerandSig},
we reduce to the non-forgeability of standard Schnorr (where the public key is not part of the signature \& without randomization)
that was proven in \cite{schnorrSecurity}.


Suppose we are given \adv interacting with \oracle as described above, and finally outputting $(\alpha^*,\msg^*,\sig^*)$.
We construct \advprime that interacts with \oracleprime which is a ``standard'' Schnorr oracle.

That is:
\begin{enumerate} 
\item \oracleprime begins by choosing a uniform $\sk\in \F$ 
\item \oracleprime computes $\pk = \sk\cdot g$ and sends \pk to \advprime. \oracleprime intializes an empty set $T'$.
\item \advprime sends queries \msg to \oracleprime and receives replies $\sig = \sign'_{\sk}(\msg)$. \oracleprime adds $(\msg,\sigma)$ to $T'$.
\item After all queries \advprime outputs $(\msg^*,\sig^*)$.
\end{enumerate}
\advprime wins if
\begin{itemize}
   \item $\versig'(\pk,\msg^*,\sig^*)$, and 
   \item $(\msg^*,\sig^*)\notin T'$
\end{itemize}
 
\advprime will simulate (\adv)'s interaction with \oracle using \oracleprime:
Given a query $(\alpha,\msg)$ of \adv, \advprime queries \oracleprime with $\msg'\defeq(\pk+\alpha\cdot g,\msg)$,
to receive reply $\sig'=(R,u')$ - \emph{this is a $\schnorr'$-signature of $\msg'$ with \sk, and we now convert this to a $\schnorr$-signature of $\msg$ with $\sk+\alpha$}.
Let $c\defeq \RO(R,\msg')=\RO(R,\pk+\alpha\cdot g, \msg)$. It sends $\sig\defeq (R,u\defeq u'+c\alpha)$ to \adv.


 We have 
\[u\cdot g = u'\cdot g +c\alpha\cdot g = R+c\cdot \pk +c\alpha\cdot g = R+ c\cdot (\pk+\alpha\cdot g) .\]
So we have $\versig(\pk+\alpha\cdot g,\msg,\sig)$.
Also $R$ is uniformly distributed, thus \advprime is answering (\adv)'s queries with the same distribution \oracle would have.

Note that the mapping $F(\alpha,\msg,\sig)\defeq (\msg',\sig')$
where $\msg'\defeq(\pk+\alpha\cdot g,\msg),\sig'\defeq (R,u-c\alpha)$ is injective.

% $T=\set{(\alpha,\msg,\sig)}$
Let $T$ be the set of tupples $(\alpha,\msg,\sig)$ such that \adv queried $(\alpha,\msg)$ and $\adv'$ answered \sig.
We have $T'= \sett{F(x)}{x\in T}$.

When \adv finally outputs $x^*=(\alpha^*,\msg^*,\sig^*)$;
\advprime outputs $F(x^*)$. 
As $F$ is injective $x^* \notin T$
implies $F(x^*)\notin T'$.

Denote $(m',\sigma')\defeq F(x^*)$.
From \cite{schnorrSecurity}'s results on unforgeability of $\schnorr'$, the probability that 
\begin{itemize}
   \item $\versig'(\pk,\msg',\sig')$, and 
   \item $(\msg',\sig')\notin T'$
\end{itemize}
is \negl.
Noting that $\versig'(\pk,\msg',\sig')\equiv \versig(\pk+\alpha\cdot g, \msg^*,\sig^*)$,
this means that the probability that
\begin{itemize}
   \item $\versig(\pk+\alpha\cdot g,\msg^*,\sig^*)$, and 
   \item $x^* \notin T$
\end{itemize}
is \negl.
This is exactly what we had to prove.
\end{proof}


We state the following theorem that is almost implicit in \cite{PS00}
\begin{thm}[Extractability of Schnorr]\label{thm:extractSchnorr}
There is an algorithm \ext with the following property.
Fix any efficient \adv and group element $\g\in\G$. Suppose that \adv produces w.p. $\gamma$
$(\pk,\msg,\sig)$ such that $\versig^{\RO}_{\g}(\pk,\msg,\sig)$.
Then given the output $(\pk,\msg,\sig)$ of \adv, and the internal randomness used by \adv in the run,
\ext produces w.p $\gamma/2$ over (\adv)'s randomness and its own randomness $s\in\F$ such that
$\pk = s\cdot \g$.
Furthermore, \ext's running time will be $P(\lambda)$ where $P$ is a polynomial depending on the running time of \adv.
\end{thm}

 


%  For the proof of the theorem, note that we can think of \sim as uniform $(\seq, \sigseq) \in \F^{3Q}$ and answering queries accordingly.
%  (Perhaps aborting on the way.)
% \begin{thm}
% For any $\eps= 1/\poly$,  \schnorr is simulation extractable with error $\eps$.
% \end{thm}
% \begin{remark}
%  An important property of our definition and this theorem is that the ``extractor succeeds almost always when the prover succeeds'';
%  in contrast with, e.g., Theorem 3 of \cite{FKMV12}
% \end{remark}
% 
% \begin{proof}
%  The proof is similar to ones in \cite{PS00,firstMPC}.
%  
%  
%  Suppose \adv has made $Q$ queries  $q_1,\ldots,q_Q$ to $\simro$, receiving replies $\seq =\seq_1,\ldots,\seq_Q$;
%  and queries $\sigquer = \sigquer_1,\ldots,\sigquer_Q$ to \simprv receiving replies $\sigseq = \sigma_1,\ldots,\sigma_Q$.
% Suppose it has prouced $(\pk,\msg,\sig)$ such that
% $\versig^\simro(\pk,\msg,\sig)=\acc$
% 
% 
%  \newcommand{\rest}[2]{\ensuremath{#1|_{#2}}\xspace}
% \newcommand{\bigset}{\ensuremath{W|_{\seq\setminus j}}\xspace}
% \newcommand{\bigsetspecific}{\ensuremath{W|_{\seq\setminus j_s(\seq)}}\xspace}
% \newcommand{\smallset}{\ensuremath{W_{\seq,s}}\xspace}
% \newcommand{\alg}{\ensuremath{\mathsf{alg}}\xspace}
% \newcommand{\domainofsequence}{\ensuremath{[\rodomsize]^Q}\xspace}
% % \begin{claim}\label{clm:goodelems}
% % For any polynomial $P$, 
% %  there is an algorithm \alg that for a $(1-1/P(\log r))$-fraction of good \seq,
% %  obtains $\secrets(\seq)$ given \seq with probability $1-1/r$ in time \polylog.
% % \end{claim}
% 
% % Denote $S=\cup_{i\in\players}\secrets_i$, where $\secrets_i$ is the vector of variables $\tau_i,\rho_{A,i},\rho_{B,i},\alpha_{A,i},\alpha_{B,i},\alpha_{C,i},\gamma_i,\beta_i$.
% 
% Think of \sigseq, and \adv's randomness as fixed. We'll show that except for a $1/P$ fraction of $\seq \in \F^Q$,
% if $(\seq,\sigseq)$ is good we retrieve \sk except with probability $2^{-\lambda}$.
% Suppose that $\sig = (R,u)$.
% Let us call \seq $\sigseq$-good if   $(\seq,\sigseq)$ is good  
% Denote by $J\in [Q]$ the index such that $q_J = (\pk,\msg,R)$.
% % 
% % For good \seq and $s\in S$, we denote by $i_s(\seq)$
% % the index corresponding to $s$ in $I(\seq)$ and by $j_s(\seq)$
% % the index corresponding to $s$ in $J(\seq)$.
% % Note that for good \seq we always have $i_s(\seq)<j_s(\seq)$.
% 
% For $j\in [Q]$, and $\seq\in \F^Q$,
% we denote by \bigset the strings $\seq'\in \F^q$
% that are equal to \seq outside of $j$.
% For $\seq\in \F^Q$,
% we denote by \smallset the set of good $\seq'\in\F^q$ that are equal
% to \seq outside of $j$, and have $J(\seq')=J(\seq)$.
% Note that the set \smallset is determined by the index $j$
% and the values of \seq outside of $j$; thus, there are at most $\F^{Q-1}\cdot Q$ such distinct sets.
% Note also that $\smallset \subseteq \bigsetspecific$.
% 
% Now given good \seq, \sim does the following.
% Denote $P'\defeq 2P\cdot Q$.
% Letting $j\defeq J(\seq)$, \alg samples $2P'(\lambda)\cdot \lambda$ strings \seq' from \bigset.
% For each one he checks if $\seq'\in \smallset$ and if $\seq'_{j}\neq \seq_{j}$.
% If both checks hold, it means, that $\adv(\sigseq,\seq)=(\pk,\msg,(R,u))$ and $\adv(\sigseq,\seq')=(\pk,\msg,(R,u'))$ are two valid signatures of \msg under
% \pk. This means \ext can obtain $\sk$ using Schnorr's extractability property.
% 
% 
% Now the question is what is the probability of not finding a sequence \seq' enabling extraction of $\sk$.
% We claim this is at most $2^{-\lambda}$, when the density of \smallset in \bigset is at least $1/P'(\lambda)$:
% In this case the density of elements of \smallset such that $\seq'_{j}\neq \seq_{j}$ is at least $1/P'(\lambda)-1/r\geq 1/2P'(\lambda)$ for large enough $\lambda$.
% Thus, the probability that no such element \seq' is found is at most $(1-1/2P'(\lambda))^{ 2P'(\lambda)\cdot\lambda}\leq e^{-\lambda}$.
% 
% Now we must bound the density of good \seq that do not have this property.
% Each such \seq belongs to a set \smallset containing at most $r/P'(\lambda)$ elements.
% Thus, there at most 
% \[\frac{r \cdot r^{Q-1}\cdot Q}{P'(\lambda)} = \frac{r^Q\cdot Q^2}{P(\lambda)\cdot Q} = \frac{r^Q}{P(\lambda)}\]
% such elements, which is a $1/P(\lambda)$ fraction of the space.
% 
% In summary, for each value of \sigseq,
% if the fraction of values \seq such that $(\sigseq,\seq)$ is good is $\eps_\sigseq$.
% We succeed in extraction, except for a $1/P$-fraction of those.
% 
% 
% \end{proof}

\newcommand{\createaddr}{\ensuremath{\mathsf{createaddr}}\xspace}
\newcommand{\makeinput}{\ensuremath{\mathsf{makeinput}}\xspace}
\newcommand{\makeoutput}{\ensuremath{\mathsf{makeoutput}}\xspace}
\newcommand{\makerandomizedoutput}{\ensuremath{\mathsf{makerandomizedoutput}}\xspace}
\newcommand{\makeoutputandnote}{\ensuremath{\mathsf{makeoutputandnote}}\xspace}
\newcommand{\maketx}{\ensuremath{\mathsf{maketx}}\xspace}
\newcommand{\makerandomizedtx}{\ensuremath{\mathsf{makerandomizedtx}}\xspace}
\newcommand{\bindvaltx}{\ensuremath{\mathsf{bindval}}\xspace}
\newcommand{\signtx}[1]{\ensuremath{\mathsf{signtx}(#1)}\xspace}
\newcommand{\notecom}{\ensuremath{\mathbf{NC}}\xspace}
\newcommand{\valcom}{\ensuremath{\mathbf{VC}}\xspace}
\newcommand{\esk}{\ensuremath{\mathsf{esk}}\xspace}
\newcommand{\note}{\ensuremath{\mathsf{note}}\xspace}
\renewcommand{\notes}{\ensuremath{\overrightarrow{\mathsf{note}}}\xspace}
\newcommand{\noteenc}{\ensuremath{\mathsf{enc}}\xspace}
\newcommand{\epk}{\ensuremath{\mathsf{epk}}\xspace}
% \newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\gr}{\ensuremath{\mathsf{g}_\mathbf{r}}\xspace}
\newcommand{\gsig}{\ensuremath{\mathsf{g}_{\mathbf{sig}}}\xspace}
\newcommand{\gnk}{\ensuremath{\mathsf{g}_{\mathbf{n}}}\xspace}
\newcommand{\gv}{\ensuremath{\mathsf{g}_{\mathbf{v}}}\xspace}
% \newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\rawtx}{\ensuremath{\mathsf{raw_{tx}}}\xspace}
\newcommand{\pretx}{\ensuremath{\mathsf{pre\mhyphen tx}}\xspace}
\newcommand{\sigval}{\ensuremath{\sigma_{\mathsf{bind}}}\xspace}
\newcommand{\rcvs}{\ensuremath{\overrightarrow{\mathsf{rcv}}}\xspace}
\newcommand{\rcms}{\ensuremath{\overrightarrow{\mathsf{rcm}}}\xspace}
\newcommand{\pak}{\ensuremath{\mathsf{pak}}\xspace}
\newcommand{\ak}{\ensuremath{\mathsf{ak}}\xspace}
\newcommand{\rcv}{\ensuremath{\mathsf{rcv}}\xspace}
\newcommand{\rk}{\ensuremath{\mathsf{rk}}\xspace}
\newcommand{\nk}{\ensuremath{\mathsf{nk}}\xspace}
\newcommand{\ovk}{\ensuremath{\mathsf{ovk}}\xspace}
\newcommand{\ivk}{\ensuremath{\mathsf{ivk}}\xspace}
\newcommand{\IVK}{\ensuremath{\mathbf{IVK}}\xspace}
\newcommand{\MPH}{\ensuremath{\mathbf{MPH}}\xspace}
\newcommand{\nsk}{\ensuremath{\mathsf{nsk}}\xspace}
\newcommand{\ask}{\ensuremath{\mathsf{ask}}\xspace}
\newcommand{\signallinputs}{\ensuremath{\mathsf{sign\mhyphen all\mhyphen inputs}}\xspace}
\newcommand{\spendverify}{\ensuremath{\mathsf{spendverify}}\xspace}
\newcommand{\pubinp}{\ensuremath{\mathrm{pub}}\xspace}
\newcommand{\wit}{\ensuremath{\mathsf{w}}\xspace}
\newcommand{\outstatement}[1]{\ensuremath{\mathsf{OUT}(#1)}\xspace}
\newcommand{\spendstatement}[1]{\ensuremath{\mathsf{SPEND}(#1)}\xspace}
\newcommand{\cm}{\ensuremath{\mathsf{cm}}\xspace}
\newcommand{\nf}{\ensuremath{\mathsf{nf}}\xspace}
\renewcommand{\path}{\ensuremath{\mathsf{path}}\xspace}
\newcommand{\cv}{\ensuremath{\mathsf{cv}}\xspace}
\newcommand{\rt}{\ensuremath{\mathsf{rt}}\xspace}
\newcommand{\prf}{\ensuremath{\pi}\xspace}
\renewcommand{\input}{\ensuremath{\mathsf{input}}\xspace}
\renewcommand{\output}{\ensuremath{\mathsf{output}}\xspace}
\newcommand{\inputs}{\ensuremath{\overrightarrow{\mathsf{input}}}\xspace}
\newcommand{\invals}{\ensuremath{\overrightarrow{\mathsf{v}}}\xspace}
\newcommand{\outvals}{\ensuremath{\overrightarrow{\mathsf{ov}}}\xspace}
\newcommand{\sigs}{\ensuremath{\overrightarrow{\mathsf{\sigma}}}\xspace}
\newcommand{\alphas}{\ensuremath{\overrightarrow{\mathsf{\alpha}}}\xspace}
\newcommand{\aks}{\ensuremath{\overrightarrow{\mathsf{ak}}}\xspace}
\newcommand{\asks}{\ensuremath{\overrightarrow{\mathsf{ask}}}\xspace}
\newcommand{\ivks}{\ensuremath{\overrightarrow{\mathsf{ivk}}}\xspace}
\newcommand{\sks}{\ensuremath{\overrightarrow{\mathsf{sk}}}\xspace}
\newcommand{\outputs}{\ensuremath{\overrightarrow{\mathsf{output}}}\xspace}
\newcommand{\rcm}{\ensuremath{\mathsf{rcm}}\xspace}
\newcommand{\val}{\ensuremath{\mathsf{v}}\xspace}
\newcommand{\outval}{\ensuremath{\mathsf{ov}}\xspace}
 \newcommand{\NF}{\ensuremath{\mathbf{NF}}\xspace}
 \newcommand{\KDF}{\ensuremath{\mathbf{KDF}}\xspace}
% \newcommand{\createaddr}{\ensuremath{\mathsf{createaddr}}\xspace}
\newcommand{\provoutput}{\ensuremath{\pi_{\mathsf{output}}}\xspace}
\newcommand{\provspend}{\ensuremath{\pi_{\mathsf{spend}}}\xspace}
\newcommand{\symencrypt}[2]{\ensuremath{\mathbf{ENC}_{#1}(#2)}\xspace}
\newcommand{\symdecrypt}[2]{\ensuremath{\mathbf{DEC}_{#1}(#2)}\xspace}
\newcommand{\sighash}{\ensuremath{\mathbf{sighash}}\xspace}
\newcommand{\outverify}{\ensuremath{\mathbf{outverify}}\xspace}
\newcommand{\MAXVAL}{\ensuremath{\mathsf{MAX}}\xspace}
\newcommand{\GH}{\ensuremath{\mathrm{GH}}\xspace}

\newcommand{\dec}{\ensuremath{\mathsf{\mathbf{dec}}}\xspace}
\newcommand{\np}{\ensuremath{\mathsf{np}}\xspace}
\newcommand{\ghash}{\ensuremath{\mathsf{GH}}\xspace}
\renewcommand{\d}{\ensuremath{\mathsf{d}}\xspace}
\newcommand{\secret}{\ensuremath{\mathsf{shared\mhyphen secret}}\xspace}
\newcommand{\jof}[1]{\ensuremath{#1_j}\xspace}
\section{Description of Sapling}
 \subsection{Basic components}
\subsection*{Functions, and their requirements:}
We do not explicitly state function domains and ranges; see the spec for more details.
Whenever discussing a function in the properties below, we always think of an infinite sequence of functions indexed by the security paramter $\lambda$.
\begin{enumerate}
 \item For any fixed values $\gd,\pk,\val$, and for any $\eps\geq 0$, $\notecom(\gd,\pk,\val,\rcm)$ is $\eps$-close to uniform when $\rcm$ is $\eps$-close to uniform.
 \item \notecom is collision resistant - i.e. the probability of finding $\note,\note'$ such that $\notecom(\note)=\notecom(\note')$ is \negl. \footnote{A caveat here is that this is true when the $\rcm$ parameter is thought of as a field element; in the actual circuit it is received as a string of bits where some elements of $\F$ have multiple representations; inspection of the proof shows that it suffices that CR w.r.t \rcm as a field element; same story with \rcv in \valcom.}
\item For any fixed \val and any $\eps\geq 0$, $\valcom(\val,\rcv)$ is $\eps$-close to uniform whenever \rcv is $\eps$-close to uniform. 
\item \valcom is collision-resistant.
\item \sighash is collision-resistant.
\item \IVK is collision-resistant.
\item \NF is modeled as a random oracle outputting at least $\lambda$ bits (and thus is in particular, collision-resistant).
\end{enumerate}
\paragraph{Generators of \G}
We assume we are given generators $\gsig,\gnk,\gr,\gv$ that were sampled in a way that except w.p \negl
an efficient \adv cannot discover the discrete log relation between any two of them.

\subsection*{Statements:}
\underline{\textbf{\outstatement{\cv,\cm,\epk}:}}
I know $\note=(\gd,\pk,\val,\rcm),\rcv,\esk$ such that 
\begin{enumerate}
 \item $\cm = \notecom(\note)$.
 \item $\cv = \valcom(\val,\rcv)$.
 \item $\epk=\esk\cdot \gd$.
 \item $\gd$ has order greater than eight.
\end{enumerate}
\noindent
\underline{\textbf{\spendstatement{\rt,\cv,\nf,\rk}:}}
I know $\path,\pos,\note=(\gd,\pk,\val,\rcm),\cm,\rcv,\alpha,\ak,\nsk$ such that 
\begin{enumerate}
 \item $\cm = \notecom(\note)$.
 \item Either $\val=0$ (``dummy note''); or \path is a merkle path from \cm at position \pos to \rt.
 \item $\rk = \ak + \alpha \cdot \gsig$.
 \item Setting $\nk \defeq \nsk\cdot \gnk, \ivk \defeq \IVK(\ak,\nk)$; we have $\pk=\ivk\cdot \gd$.
 \item $\nf = \NF(\nk,\cm,\pos)$
\end{enumerate}

\subsection*{Components}
A \emph{note} is a tupple $\note = (\gd,\pk,\val,\rcm)$ where 
\begin{enumerate}
 \item $\gd,\pk \in \G$.
 \item $\val, \rcm \in \F$
 \item $\val \leq \MAXVAL$.
\end{enumerate}

An \emph{output base} $\output=(\gd,\pk,\val)$ is the same as a note excluding the \rcm component.
\begin{remark}
 It is convenient for us to define a note with \gd rather than its \GH-preimage \d as in the spec, as this is what's given as input to the circuits; there are minor non-expoitable issues with this, see e.g. https://github.com/zcash/zcash/issues/3490.
\end{remark}



For $\ivk \in \F$ we say \note \emph{belongs to \ivk} if $\pk =\ivk \cdot \g$.\\




An \emph{input base}, usually denoted \input, will consist of the values required to make an input in a Sapling transaction, except the spending key; namely $\input = (\note,\path,\pos,\pak)$ where
\begin{itemize}
 \item \note is a note
 \item \path is a path in a merkle tree beginning from a leaf of value $\cm=\notecom(\note)$.
 \item \pos is the position of \cm amongst the leaves of the Merkle tree (\pos is redundant here as it can be derived from \path, but convenient).
 \item \pak is a proving key to make SNARK spend proofs about the note.
\end{itemize}

We say \input is \emph{consistent with \rt} if \path ends at \rt.

A \emph{transaction input}, usually denoted \inp, is the final form an input appears in a transaction; \inp consists of 
\begin{enumerate}
 \item A value commitment \cv.
 \item A nullifier \nf.
 \item A Merkle root \rt of the tree containing the used note.
 \item A public key \rk that is (allegedely) a randomized version of the spent note's proving key \ak.
 \item A SNARK proof \prf for the statement \spendstatement{\rt,\cv,\nf,\rk}.
\end{enumerate}


\subsection{Methods}

We use the convention that $\ell$ denotes the number of inputs in a transaction, and $s$ the number of outputs.

\noindent
\underline{$\makeinput(\rt,\input=(\note,\path,\pos,\pak),\rcv,\alpha)$}

where \input is an input base consistent with \rt.

\begin{enumerate}
\item \cm = \notecom(\note)
 \item \nf = \NF(\nk,\cm,\pos)
 \item Define $\rk\defeq \ak +\alpha\cdot \g, \cv\defeq  \val\cdot \gv+ \rcv\cdot \gr $.
 \item Let $\prf = \provspend(\cv,\rt,\nf,\rk;\note,\pak,\alpha,\path,\pos)$.
 \item Output $(\cv,\rt,\nf,\rk,\pi)$.
\end{enumerate}

\noindent
\underline{\makeoutput(\note=(\gd,\pk,\val,\rcm),\rcv)},
\begin{enumerate}
 \item Choose random $\esk\in \F$.
 \item Let $\cv\defeq \valcom(\val,\rcv) = \val\cdot \gv + \rcv\cdot \gr$.
 \item Let $\note = (\gd,\pk,\val,\rcm)$ and $\cm\defeq \notecom(\note)$.
 \item Let $\epk = \esk\cdot \gd$.
 \item Let $\noteenc = \symencrypt{\KDF(\esk\cdot \gd)}{\note}$
 \item Let $\prf = \provoutput(\epk,\cm,\cv;\note,\rcv,\esk)$.
 \item Output $(\cv,\cm,\epk,\prf,\noteenc)$
\end{enumerate}
\noindent
\underline{\makerandomizedoutput(\note=(\gd,\pk,\val),\rcv)},
\begin{enumerate}
 \item Choose random $\esk,\rcm\in \F$.
 \item Let $\cv\defeq \valcom(\val,\rcv) = \val\cdot \gv + \rcv\cdot \gr$.
 \item Let $\note = (\gd,\pk,\val,\rcm)$ and $\cm\defeq \notecom(\note)$.
 \item Let $\epk = \esk\cdot \gd$.
 \item Let $\noteenc = \symencrypt{\KDF(\esk\cdot \pk)}{\note}$
 \item Let $\prf = \provoutput(\epk,\cm,\cv;\note,\rcv,\esk)$.
 \item Output $(\cv,\cm,\epk,\prf,\noteenc)$
\end{enumerate}
\noindent
\underline{\bindvaltx(\rawtx=(\inps,\outs,\vbal),\rcvs)}

\begin{enumerate}
 \item Let $r\defeq\sum_{i=1}^\ell \rcv_i - \sum_{i=\ell+1}^{\ell+s}\rcv_i$
 \item Let $S\defeq\sum_{i=1}^\ell \cv_i - \sum_{i=\ell+1}^{\ell+s}\cv_i-\vbal\cdot \gv$
 \item Let $\sigval \defeq \sign_{\gr}(r,\sighash(\rawtx))$.
 \item Output $\pretx\defeq (\rawtx,\sigval)$.
\end{enumerate}

% \underline{\verifyinput{\inp=(\nf,\rt,\rk,\pi}}
\noindent
\underline{\signtx{\pretx=(\rawtx,\sigval),\asks,\alphas}}
\begin{enumerate}
 \item For each $i\in [\ell]$, let $\sigma_i\defeq \sign_{\gsig}(\ask_i+\alpha_i,\sighash(\rawtx))$
 \item Let $\sigs\defeq (\sig_1,\ldots,\sig_\ell)$.
 \item Output $(\rawtx,\sigs)$.
\end{enumerate}

Given $(\rt,\vbal)$ we say $(\inputs,\outputs)$ is \emph{consistent} with $\rt,\vbal$,

if
\begin{itemize}
 \item for each $j\in [\ell]$ $\input_j$ is consistient with \rt, i.e. \jof{\pak} is from $\notecom(\note_j)$ to \rt,
 \item $\sum_{j=1}^{\ell} \val_j-\sum_{j=\ell+1}^{\ell+s} \val_j=\vbal$.
 \item the positions \sett{\pos_j}{j\in [\ell]} are all distinct.
\end{itemize}


and \\
\noindent
\underline{\makerandomizedtx(\rt,\vbal,\inputs,\outputs)}

\noindent
where $\input_j = (\note_j,\pak_j,\path_j,\pos_j), \output_j =(\gd_j,\pk_j,\val_j)$
\begin{enumerate}
 \item Choose random $\rcvs\in \F^s$.
 \item For $j\in [\ell]$, $\inp_j = \makeinput(\rt,\input_j,\rcv_j)$
 \item For $j\in [s]$, $\out_j=\makeoutput(\output_j,\rcv_j)$
 \item $\pretx = \bindvaltx(\inps,\outs,\vbal)$.
 \item Choose random $\alphas\in \F^{\ell}$.
 \item Output $\tx = \signtx{\pretx,\ask,\alphas}$
\end{enumerate}

\noindent
\underline{\maketx(\inputs,\outputs,\rcvs,\ask,\pak)}
where $\input_j = (\val_j,\note_j,\pak_j,\path_j,\pos_j), \output_j =(\gd_j,\pk_j,\val_j,\rcm_j)$
\begin{enumerate}
\item Choose random $\alphas\in\F^{\ell}$.
 \item For $j\in [\ell]$, $\inp_j = \makeinput(\input_j,\rcv_j,\alpha_j,\pak)$
 \item For $j\in [s]$, $\out_j=\makeoutput(\output_j,\rcv_j)$
 \item Let $\vbal \defeq \sum_{i=1}^\ell\val_i - \sum_{j=\ell+1}^{\ell+s}\val_j$.
 \item $\pretx = \bindvaltx(\inps,\outs,\vbal,\rcvs)$.
 \item Let $\tx = \signtx{\pretx,\alphas,\ask}$
\end{enumerate}

\noindent
\underline{\verifytx{\ledger}{\tx}}

\begin{enumerate}
\item Suppose that $\tx=(\rawtx,\sigs)$.
\item For each $\inp_i =(\rt,\cv,\nf,\rk,\prf)\in \inps(\tx)$,
 \begin{itemize}
  \item Check that $\nf \notin \nfof{\ledger}\cup \set{\nfof{\inp_1},\ldots,\nfof{\inp_{i-1}}}$.
  \item Check that $\spendverify(\rt,\cv,\nf,\rk;\prf)$.
  \item Check that $\versig^{\RO}_{\gsig}(\rk,\sighash(\rawtx),\sig_i)$
 \end{itemize}
\item For each $\out = (\cv,\cm,\epk,\prf,\noteenc)\in\outs(\tx)$, check that  $\outverify(\cv,\cm,\epk;\prf)$
\item Let $S\defeq\sum_{i=1}^\ell \cv_i - \sum_{i=\ell+1}^{\ell+s}\cv_i-\vbal\cdot \gv$.
\item Check that $\versig^{\RO}_{\gr}(S,\sighash(\rawtx),\sigval)$.
\end{enumerate}


%where $\note =$ 





\section{Non-Malleability of Sapling w.r.t. delegated spenders}


We make the simplifying assumption when modelling non-malleability in this writeup; that \emph{there is only one spending key $(\ask,\nsk)$ of the honest signer  involved, and all addresses are diversifed addresses derived from this spending key}.
\subsection*{Modelling the adversary:}
We wish to show that the delegated spender cannot create any new transactions of her own.
We model this claim with the following non-malleability game:
We model the honest signer as an oracle \oracle that \adv interacts with as follows.
% 
% \paragraph{Create address queries}
% \oracle stores an initially empty set $K$ of secret keys to its addresses.
% When \adv issues a \createaddr query. \oracle
% \begin{enumerate}
%  \item Chooses random $\sk \leftarrow \keyset$
%  \item Adds $\sk$ to $K$.
%  \item Derives the corresponding proof authorizing key $\pak(\sk)$.
%  \item Sends \pak to \adv.
% \end{enumerate}


\oracle begins by choosing a new spending key $(\ask,\nsk)\leftarrow \keyset$ and sending the corresponding proof authorizing key
$\pak=(\ak,\nsk)$ to \adv.  Where $\ak=\ask\cdot \g$.


Afterwords, 
\adv can make \signallinputs queries to \oracle,
which intuitively correspond to asking for signatures on transactions whose inputs have spending key $(\ask,\nsk)$ (though see remark). 
\paragraph{Sign-all-inputs queries}% - $\signallinputs(\rawtx,\aks,\alphas)$}
\begin{enumerate}
 \item \adv sends $(\pretx=(\rawtx,\sigval),\alphas)$ to \oracle.
 Where $\rawtx = (\inps,\outs,\vbal)$
 \item \oracle checks if $\spendverify(\pubinp_i,\prf_i)$ holds for each $i\in [\ell]$ and otherwise aborts.
 \item  \oracle computes for $i\in [\ell]$, $\sig_i = \sign_{\g}(\ask+\alpha_i,\sighash(\rawtx))$.
 \item Let $\sigs\defeq (\sig_1,\ldots,\sig_\ell)$. \oracle return $\tx\defeq(\rawtx,\sigval,\sigs)$. 
\end{enumerate}
\begin{remark}
 The second item is another way of saying we assume \adv can only ask \oracle for signatures of transactions with legitimate spend proofs.
 Otherwise the proof currently fails as we need to be able to extract the witness from each input.
\end{remark}

% \textbf{\oracle must record its answers to previous \signallinputs queries and answer identically to repeating queries}
% \begin{remark}
% This requirement is needed for the non-malleability property stated in Claim \ref{clm:nmal}. Different signatures on repeating queries enable \adv to violate the claim by mixing and matching different signatures for the same raw transaction. Alternatives are to only demand the non-signature part is NM, or to have each $\sig_i$, also sign the previous signatures.
%  
% \end{remark}


\paragraph{Terminology:}
We refer below to a transaction \tx as $\tx=(\rawtx,\sigval,\sigs)$, where \sigs contains the $\ell$ input signatures and \sigval is as described above in 
\maketx{} 
that are added during \signallinputs \emph{and} the signature \sigval added in the last step of \maketx.

Non-malleability says, \adv should not be able to create a new valid transaction with inputs belonging to \oracle,
even after seeing transactions of its choice with inputs of \oracle. New will mean that the \rawtx part will be new.
(If we had changed the signature scheme to sign in order and have each signature sign the previous ones we could have required that
\tx including the signature part must be different from all previous transactions).

The way we formalize ``transaction with inputs of \oracle'' is that the transaction created by \adv contains 
overlapping nullifiers with the transactions signed previously by \oracle; precisely transactions that are outputs of \signallinputs queries.

\begin{remark}\label{rem:weirdstuff}
 A somewhat odd thing about the construction with the delegated spender, is that valid transactions signed by \oracle, do not exactly correspond to transactions whose inputs \oracle knows the spending key of. We can only say \oracle and \adv \emph{together} know the spending key.
 For example, given $(\ak,\nsk)$, \adv can choose random $s\in \F$, set $\ak' \defeq \ak + s\cdot \g$.   
 Now when \adv wants to sign an input in address $\ak'$, i.e. with some randomized key $\rk = \ak'+ \alpha \g  = \ak + (s+\alpha)\cdot \g$,
 it can give \oracle the randomization $\alpha' = s+\alpha$.
 
 A way to avoid these oddities is to have \oracle only sign transactions where he recognizes the nullifiers as belonging to a note of his.
 For our purposes here, we get a stronger result without this restriction by showing non-malleability holds when \oracle signs \emph{any} transaction.
\end{remark}



\paragraph{Some more terminology}
Given a validly formatted transaction $\tx=((\inps,\outs,\vbal), \sigval,\sigs)$,
we define 
\begin{itemize}
 \item \nfof{\tx} to be the set of nullifiers appearing in one of its inputs; so $\nfof{\tx}\defeq \sett{\nfof{\inp}}{\inp\in\inps}$.
\item \rkof{\tx} the set of randomized public keys appearing in inputs of \tx, so $\rkof{\tx}\defeq \sett{\rkof{\inp}}{\inp\in\inps}$.
\item $\rawof{tx}\defeq (\inps,\outs,\vbal)$. For a set $T$ of validly formed transactions we define $\rawof{T}\defeq \sett{\rawof{\tx}}{\tx\in T}$
\end{itemize}
\begin{claim}[Non-malleability w.r.t delegated spenders]\label{clm:nmal-sapling}
Fix any efficient \adv interacting with \oracle as described above.
Let $T=\set{\tx'}$ be the set of transactions that are replies of \oracle to \adv's \signallinputs queries.
The probability that \adv manages to output a ledger \ledger and transaction \tx such that

\begin{enumerate}
 \item	$\verifytx{\ledger}{\tx}=\acc$,
 \item  $\rawof{\tx}$ is not a prefix of an element of $T$.
 \item $\nfof{\tx} \cap \nfof{\tx'}\neq \emptyset$ for some  $\tx'\in T$.
\end{enumerate}
is \negl. 
\end{claim}
\begin{proof}
Let \adv be an algorithm that after interacting with \oracle as described above outputs \ledger,\tx.
Let \eps be the probability that \ledger, \tx satisfy the above.

We construct \advprime that receives a randomized forgery challenge for \schnorr as described in Definition \ref{dfn:sigscheme},
and with probability $\eps-\negl$ either
\begin{itemize}
\item outputs a collision of \sighash
\item outputs a collision of \NF, 
 \item outputs a collision of \notecom, 
 \item outputs a collision of \IVK, 
\item  Constructs a signature forgery for \schnorr w.r.t randomization.
\end{itemize}


Then, from CR of \sighash, \NF,\notecom,\IVK and Theorem \ref{thm:schnorr-nf} the claim follows.

\advprime works as follows:
\begin{enumerate}
\item \advprime will receive a challenge \ak for the signature scheme \schnorr from a party \oracle.
 \item \advprime chooses random $\nsk\in \G$ and sends to \adv the proof authorizing key $\pak=(\nsk,\ak)$ 
 \ariel{note that here we need to make a spending key that is not from the same seed \sk}
 \item When \adv makes a \signallinputs query $(\rawtx,\alphas)$ \advprime first checks that the proofs in \rawtx are valid (as \oracle does in the description of \signallinputs queries) and then answers with \sigs where $\sig_i\defeq \simprv(\pk+\alpha\cdot g,\msg)$. If during invocations to \simprv, \simro is queried on a point on which \adv queried \RO, \advprime aborts. (Note that the point queried by \simro is $(R,\pk,\msg)$ for a uniform $R$ chosen only during the execution of \simprv, so the probability such a point was already queried is \negl.)
 \item When \advprime makes a query to \RO, \adv answers according to \RO unless the query has been answered according to \simro during invocations of \simprv in \signallinputs queries; in which case \advprime answers according to \simprv. (This doesn't change the distribution of \RO from the perspective of \adv.)
 \item When \adv outputs \ledger, \tx: \advprime checks that it indeed satisfies the challenge - that is 
  $\verifytx{\ledger}{\tx}$; \tx contains an input \inp with $\nf=\nfof{\inp}$ being equal to $\nf(\inp')$ for some $\inp'\in \tx'$ for some $\tx'\in T$;
  appearing in one of the \signallinputs queries of \adv; and $\rawtx\notin \rawof{T}$. If not \advprime aborts.
\item \advprime checks if  $\sighash(\rawtx)= \sighash(\rawtx')$ for some $\tx'\in T$ with $\rawtx'\neq \rawtx$. If so it outputs $(\rawtx,\rawtx')$ as a collision of \sighash.
 \item Let $R\defeq\set{\rk_1,\ldots,\rk_\ell}$ be the randomized public keys in the inputs of \tx,
 and $R'\defeq \set{\rk'_1,\ldots,\rk'_{\ell'}}$ be the randomized public keys in the inputs of \tx'.
 \advprime checks if $R'\cap R \neq \emptyset$, i.e. $\rk_i=\rk'_j$ for some $i,j$.
 In this case it outputs the forgery $(\alpha'_j,\sighash(\rawtx),\sig_i)$.
 \item Otherwise let \ext be the extractor guaranteed to exist for the combined party \advprime,\oracle up to the point in
 step 5 where \adv outputted \tx.
 Except with probability \negl, \ext outputs a witness $\wit=(\note,\pak=(\ak,\nsk),\alpha,\path,\pos)$.
 Similarly there is an extractor \ext' for the input \inp' in \tx' giving us a witness $\wit'=(\note',\pak'=(\ak',\nsk'),\alpha',\path',\pos')$.
\item Let $\nk\defeq \nsk\cdot \g, \nk'\defeq \nsk'\cdot \g$.  We have \[\NF(\nk,\cm,\pos) = \NF(\nk',\cm',\pos')=\nf\]
If $\nk\neq\nk',\cm\neq\cm'$ or $\pos\neq \pos'$ \advprime outputs $(\nk,\cm,\pos), (\nk',\cm',\pos')$ as a collision of \NF.
\item Otherwise, we have $\notecom(\note)=\notecom(\note')=\cm$.
If $\note \neq \note'$, \advprime outputs $\note,\note'$ as a collision of \notecom.

\item Otherwise we have $\note=\note'=(\gd,\pk,\val,\rcm)$.
Defining
$\ivk\defeq \IVK(\ak,\nk), \ivk'\defeq \IVK(\ak',\nk)$,
we have $\pk= \ivk\cdot \gd = \ivk'\cdot \gd$. 
Thus, $\ivk=\ivk'$.
(Important here that \ivk representation is unique and it is cause dfn of $\IVK$ has $mod\;\; 2^{\ell_{\ivk}=251}$.)
If $\ak\neq \ak'$, \advprime outputs $(\ak,\nk),(\ak,\nk')$ as a collision of \IVK.

\item Otherwise, we have $\ak=\ak'$.
 Now, \adv knows $\alpha^*$ such that $\rk' = \ak^* + \alpha^*\cdot \g$, where $\ak^*$ is from the forgery challenger (as he used $(\alpha^*,\sighash(\rawtx'))$ in the \signallinputs query for \tx' for input \inp').
And also $\rk' = \ak' + \alpha'\cdot \g$.
So $\ak=\ak'= \ak^* + (\alpha^*-\alpha')\cdot\g$.
And $\rk = \ak^* +(\alpha^*-\alpha'+\alpha)\cdot \g$.
Thus, in this case \advprime outputs $(\alpha^*-\alpha'+\alpha, \sigma, \sighash(\rawtx))$ as a signature forgery.
 
\end{enumerate}

\end{proof}
\newcommand{\tree}{\ensuremath{\mathsf{T}}\xspace}
\newcommand{\curnotes}{\ensuremath{\mathsf{N}}\xspace}

\newcommand{\maketransaction}{\ensuremath{\mathsf{maketransaction}}\xspace}
\subsection{Modelling the outside adversary}

\underline{$\maketransaction(\inputs,\outputs,\vbal,\ask)$}:
\begin{enumerate}
 \item For $i\in [\ell]$, check where $\input_i$ appears in the compute $\input_i\defeq \makeinput({{\inp}}_i)$.
\item Check that $\sum_{i=1}^\ell \val_i - \sum_{j=1}^s \outval_j=\vbal$.
If this is the case then $(\inputs,\outputs,\vbal)$ is a \emph{valid input} to \maketransaction.
Otherwise output \rej and abort.
 \item For $j\in [s]$, compute $\output_j \defeq \makeoutput({\out_j})$.
 \item Choose uniform $\rcvs\in \F^s$ and output $\signallinputs(\maketx{(\inputs,\outputs,\vbal,\rcvs)},\ask)$
 
\end{enumerate}

\oracle begins by choosing a uniform spending key $(\ask,\nsk)\in\keyset$.
And generates the corresponding keys $\ak\defeq \ask\cdot \g ,\nk\defeq \nsk\cdot\g, \ivk \defeq\IVK(\ak,\nk)$. 
\adv and \oracle initialize an empty set $T$ of diversifed addresses.
% \adv and \oracle initialize an empty merkle tree \tree
 \adv and \oracle initialize an empty set of current notes \curnotes. 
\adv can make two kinds of queries.

\paragraph{Get new diversifed address queries}
\begin{itemize}
\item\oracle chooses $\gd\in \G$ according to the distribution \GH of the group hash output.
\item\oracle then outputs the diversifed address $(\gd,\pk \defeq \ivk\cdot \gd)$.
\item \adv and \oracle add $(\gd,\pk)$ to the set of diversifed addresses $T$.
\end{itemize}
\paragraph{Make transaction queries}
\begin{itemize}
\item \adv chooses extended input notes $\input_1,\ldots,\input_\ell\in\curnotes$.
\item \adv chooses output notes $\output_1,\ldots,\output_s$, with $\output_j = (\gd_j,\pk_j,\val_j,\rcm_j)$, for $(\gd_j,\pk_j)\in T$.
\item \adv Chooses uniform $\rcvs\in \F^{s+\ell}$.
\item \adv sends $(\inputs,\outputs,\rcvs)$ to \oracle.
% \item \oracle computes $\inputs$ with $\inp_j\defeq \makeinput(\input_j)$, and $(\note_j,\out_j)= \makeoutputandnote(\output_j)$.
\item \oracle returns $\tx\defeq \maketx(\inputs,\outputs,\rcvs,\ask,\pak)$ to \adv.
\item \adv and \oracle add $\output_j$ to \curnotes for each $j$ s.t. $(\gd_j,\pk_j)\in T$.
\item \adv and \oracle remove the elements of \inputs from \curnotes.
\end{itemize}


 
\subsection{Non-malleability w.r.t outside adversary}
\begin{claim}\label{clm:nmal-sapling-outside}
 Suppose \adv interacts with \oracle as described above.
 Then it outputs a transaction $(\ledger,\tx,\inp\in\tx)$.
 The probability that there exists $\tx'\in T,\inp'\in \inputs(\tx')$ such that 
 \begin{enumerate}
  \item $\rawof{\tx}\neq \rawof{\tx'},\forall \tx'\in T$.
  \item $\nf(\inp)=\nf(\inp')$.
 \end{enumerate}
is \negl.
\end{claim}
\begin{proof}
Reduce to Claim \ref{clm:nmal-sapling}.
We
\end{proof}
\subsection{Indistinguishability w.r.t outside adversaries}
Let us say that random variables $X,Y$ are $\gamma$-close to independent if for
any events $A,B$
\[|\pr(X\in A \wedge Y\in B)-\pr(X\in A)\cdot \pr(Y\in B)|\leq \gamma.\]


A calculation proves
\begin{claim}\label{clm:close_to_ind}
 Suppose $X=(X_1,X_2), Y=(Y_1,Y_2)$ are such that 
 \begin{itemize}
 \item $X_1$ and $Y_1$ are $\gamma_1$-independent.
  \item 
 e.w.p $\gamma_2$ over the value $(x_1,y_1)$ of $(X_1,Y_1)$, $(X|X_1=x_1), (Y|Y_1 = y_1)$ are $\gamma_3$-independent,
 \end{itemize}

 then $X,Y$ are $\gamma_1+\gamma_2+\gamma_3$-close to independent.
 \end{claim}

 Induction then shows that
 \begin{claim}\label{clm:neg_close_to_ind}
  Suppose $t=\poly$. Suppose random variables $X=(X_1,\ldots,X_t),Y=(Y_1,\ldots,Y_t)$ are such that
  for any $i\in [n]$, e.w.p \negl over the value $(x_1,\ldots,x_{i-1},y_1,\ldots,y_{i-1})$ of $(X_1,\ldots,X_{i-1},Y_{1},\ldots,Y_{i-1})$
  $(X_i|(X_1,\ldots,X_{i-1})=(x_1,\ldots,x_{i-1}))$ and $(Y_i|(Y_1,\ldots,Y_{i-1})=(y_1,\ldots,y_{i-1}))$ are \negl-close to independent.
  
  Then $X,Y$ are \negl-close to independent.
 \end{claim}




\begin{thm}\label{thm:indist-sapling}
% Fix any efficient \adv.
% Suppose that \adv interacts with \oracle as described above.
% Then \adv outputs $\ell,s,\inputs,\outputs,\inputs',\outputs', |\inputs|=|\inputs'|=\ell,|\outputs|=|\outputs'|=s$.
Fix any $\rt,\vbal$.
Fix any $(\inputs,\outputs)$ that is consistent with $\rt,\vbal$.
%Denote by $\disttx(\inputs,\outputs)$ the distribution of $\makerandomizedtx(\rt,\vbal,\inputs,\outputs)$.

Assume that 
\begin{enumerate}
 \item 
$\NF(\nk,\notecom(\note),\pos)= \RO(\nk,\MPH(\note,\pos))$ where \RO is a random oracle and \MPH is a collision-resistant function\footnote{The requirement here may seem a bit odd; it models the fact the $\notecom(\note)$ is a pedersen hash which is combined in \NF with a $\pos$-multiple of an independent group generator, followed by an application of BLAKE-2 on the result prefixed with \nk. In particular, BLAKE-2 takes the place of \RO in the impelmentation.}

\item
\KDF is also a random oracle.
\item \symencrypt{K}{m} produces a uniform output when $K$ is uniform and $m$ is fixed.
\item The SNARK we are using is witness indistinguishable - i.e. the proof distribution depends \emph{only} on the public input and not on the witness.
\end{enumerate}


Then, the probability of an efficient \adv finding $\rt,\vbal,\inputs,\outputs,\inputs',\outputs'$
such that
\begin{itemize}
 \item 
$|\inputs|=|\inputs'| = \ell$, $|\outputs|=|\outputs'| =s $. 
\item The positioned notes in \inputs and $\inputs'$ are all distinct.
\item $(\inputs,\outputs)$ and $(\inputs',\outputs')$ are both consistent with $\rt,\vbal$
\item The distributions of the random variables $D\defeq \makerandomizedtx(\rt,\vbal,\inputs,\outputs)$ and 

$D'\defeq \makerandomizedtx(\rt,\vbal,\inputs',\outputs')$,
over the randomness of the oracles \RO,\KDF and \ROsig of the signing algorithm, and the inner randomness of the signer, SNARK prover and the \makerandomizedtx method,
are not identical and independent
\end{itemize}
is \negl.

\end{thm}
Let us denote by $(\inps,\outs,\sigval,\sigs)$ the output of $\makerandomizedtx(\rt,\vbal,\inputs,\outputs$
and by $(\inps',\outs',\sigval',\sigs')$ the output of $\makerandomizedtx(\rt,\vbal,\inputs',\outputs')$
when using independent inner randomness, but joint randomness for the oracles $\RO,\KDF$.
\begin{proof}
$\inp_1,\ldots,\inp_\ell,\inp'_1,\ldots,\inp'_\ell$
are results of invocations of \makeinput with independent randomness
$\rcv,\alpha$ and independent randomness of the SNARK prover.
$\out_1,\ldots,\out_s,\out'_1,\ldots,\out'_s$ are outputs of invocations of \makerandomizedoutput with
independent randomness $\esk,\rcm,\rcv$ and independent randomness of the SNARK prover.
Inspection shows the only oppurtunity for dependence is having 
the random oracles \KDF and \RO queried at the same point during different invocations.
We argue the probability for this is \negl:
\begin{enumerate}
 \item \RO will have a repeated query during computing of \nf, iff for some $i\neq j\in [\ell]$ 
 $(\nk_i,\MPH(\note_i,\pos_i)) =(\nk_j,\MPH(\note_j,\pos_j))$.
 As the notes are distinct, this would require finding a collision of \MPH.
 \item \KDF will have a repeated query iff for some $i\neq j \in [s]$
 $\esk_i\cdot \pk_i = \esk_j \cdot \pk_j$; this happens with \negl probability as \esk is chosen independently for
 each output.
\end{enumerate}

\end{proof}

We know show that corresponding inputs and outputs are independent and identically distributed except w.p \negl.

\begin{claim}\label{clm:inps-areind}
The probability of an efficient \adv finding input bases \input,\input' containing distinct positioned notes consistent with \rt such that, denoting by $\inp,\inp'$ the random variables 
\begin{itemize}
 \item 
$\inp = \makeinput(\rt,\input,\alpha,\rcv)$ for uniform $\alpha,\rcv \in \F$
\item
$\inp' = \makeinput(\rt,\input',\alpha',\rcv')$ for uniform $\alpha',\rcv' \in \F$
\end{itemize}
they are not identically distributed and \negl-close to independent;
is \negl.

\end{claim}
\begin{proof}
%The first item:
We show that except w.p. \negl over the randomness of \adv, any corresponding elements in $\inp,\inp'$ are distributed identically conditioned on fixing to an identical value of the previous elements, and independent conditioned on any fixed of previous elements.
 
 Suppose $\inp=(\nf',\rt',\rk',\cv',\prf)$', and $\inp=(\nf',\rt',\rk',\cv',\prf')$.
 \begin{itemize}
  \item  $\nf = \NF(\nk,\cm,\pos)=\RO(\nk,\MPH(\note,\pos))$ and $\nf'=\RO(\nk',\MPH(\note,\pos)$. As $(\note,\pos)$ and $(\note',\pos')$ are distinct, there are outputs of \RO on distinct inputs, and thus are both uniform and independet from each other; \emph{unless} $\MPH(\note,\pos) = \MPH(\note',\pos')$, but \adv can only find
  such $(\note,\pos),(\note',\pos')$ with probability \negl.
  \item $\rt=\rt'$.
  \item $\rk=\ak + \alpha\cdot \g$, $\rk' = \alpha' + \cdot \g$. Are independent and both uniform in \G because of the uniform choice of $\alpha,\alpha'$ in \makerandomizedtx.
  \item $\cv=\val\cdot \gv + \rcv\cdot \gr$,$\cv'=\val'\cdot \gv' + \rcv'\cdot \gr'$. Are uniform in \G and independent of each other because of the uniform and independent choices of $\rcv,\rcv'\in \F$ in the executions of \makerandomizedtx.
  \item $\prf,\prf'$ - When  $(\nf,\rt,\rk,\cv)=(\nf',\rt',\rk',\cv')$, it follows from the witness indistinguishability of the SNARK
  that $\prf$ and $\prf'$ are identically distributed. They are independent for any fixing of the previous values, as given this fixing the value
  of $\prf,\prf'$ depends only on the inner randomness of the SNARK prover.
 \end{itemize}
 
\end{proof} 
\newcommand{\primeof}[1]{\ensuremath{#1 '}\xspace} 
 We show a similar statement for outputs. 
\begin{claim}\label{clm:outs-areind}
For any output bases \output,\primeof{\output}, denoting by $\out,\out'$ the random variables 
\begin{itemize}
 \item 
$\out = \makerandomizedoutput(\output,\rcv)$ for uniform $\rcv \in \F$
\item
$\out' = \makerandomizedoutput(\output',\rcv')$ for uniform $\rcv' \in \F$
\end{itemize}
\out and $\out'$ are identically distributed and \negl-close to independent.

\end{claim}
\begin{proof}
Suppose $\out=(\cv,\epk,\prf,\noteenc)$, and $\out'=(\cv',\epk',\prf',\noteenc')$ 
We show that except w.p. \negl over the randomness of \adv, any corresponding elements in $\inp,\inp'$ are distributed identically conditioned on fixing to an identical value of the previous elements, and independent conditioned on any fixed of previous elements, except for the last elements $\noteenc,\noteenc'$ where w.p. \negl the fixing of previous elements will create a dependence between \noteenc and $\noteenc'$.
The claim then follows from Claim \ref{clm:close_to_ind}.
 \begin{itemize}
  \item $\cv=\val\cdot \gv + \rcv\cdot \gr,\cv'=\val'\cdot \gv + \rcv'\cdot \gr$: are independent and uniform in \G because of the independent uniform choices of $\rcv,\rcv'\in \F$ in \makerandomizedtx.
  \item $\cm = \notecom(\gd,\pk,\val,\rcm)$,$\cm' = \notecom(\gd',\pk',\val',\rcm')$: are uniform and independent in \G because of the independent uniform choices of $\rcm,\rcm'\in \F$ in \makerandomizedoutput.
  \item $\epk=\esk\cdot \gd,\epk'=\esk'\cdot \gd$ are uniform and independent in \G because of the independent and uniform choices of $\esk,\esk'\in \F$ in \makerandomizedoutput.
  \item $\prf,\prf'$ - Assuming the pubic inputs $(\epk,\cm,\cv)=(\epk',\cm',\cv')$, it follows from the witness indistinguishability of the SNARK
  that $\prf$ and $\prf'$ are identically distributed. They are independent for any fixing of the previous values, as given this fixing the value
  of $\prf,\prf'$ depends only on the inner randomness of the SNARK prover.
  \item $\noteenc = \symencrypt{\KDF(\esk\cdot\pk)}{(\gd,\pk,\val)}$,$\noteenc' = \symencrypt{\KDF(\esk'\cdot\pk')}{(\gd',\pk',\val')}$:
 Assuming $\esk\cdot \pk\neq \esk'\cdot \pk'$, we have that the encryption keys $\KDF(\esk\cdot\pk),\KDF(\esk'\cdot\pk')$ are uniform and independent.
 And thus by the theorem's assumption $\noteenc,\noteenc'$ are uniform and independent in this case. This is not the case only when the previous elements
 $\epk,\epk'$ imply $\esk=\esk'$ which happens w.p $1/|\F| = \negl$.
  \end{itemize}
\end{proof}



Now it's easy to see that
\begin{claim}\label{clm:ind_of_inputs}
Except with probability \negl, over the randomness of \adv,
 $\inp_1,\ldots,\inp_\ell,\out_1,\ldots,\out_s,\inp'_1,\ldots,\inp'_\ell,\out'_1,\ldots,\out'_s$ are \negl-close to independent random variables.
\end{claim}
\begin{proof}
  It follows from the above two claims that any pair of inputs, or pair of outputs are \negl-close to independent.
  Since there are no colliding random oracle queries between inputs and outputs, the claim follows.
\end{proof}


Denote $\sig_0\defeq \sigval$.


\begin{claim}\label{clm:ind_of_sigs}
For any $i\in [0..\ell]$, and any 
 Conditioned on any fixing of $\inp_1,\ldots,\inp_\ell,\out_1,\ldots,\out_s,\inp'_1,\ldots,\inp'_\ell,\out'_1,\ldots,\out'_s,\sig_0,\ldots,\sig_{i-1},\sig'_0,\ldots,\sig'_{i-1}$ the values
 $\set{\sig_i,\sig'_i}$ are \negl-close to independent.
\end{claim}
\begin{proof}
 The distribution of any given $\sig_i$ is of the form $R,u$ where $R\in \G$ is uniformly chosen by the signing algorithm as $a\cdot \gr$,
 and $u=a+c\cdot \sk$ where $c=\ROsig(R,\pk,\sighash(\rawtx)$.
 For dependence to be created we would need $R=R`$ which happens with probability $1/|\F|$.
 More formally, e.w.p $1/|\F|$ over the probability of the values $x,y$ of $\sig_i,\sig'_i$,
 we have 
\[\pr(\sig_i=x \wedge \sig'_i =y)=\pr(\sig_i =x)\cdot \pr(\sig'_i =y)\]
 which means $\sig_i,\sig'_i$ (conditioned on any fixing of all previous variables mentioned in the claim statement) are \negl-close to independent.
 
\end{proof}



\begin{proof} (of Theorem \ref{thm:indist-sapling})
Note that 
% $\inp_1,\ldots,\inp_\ell, \out_1,\ldots,\out_s$ are all independent from each other. (Here we use that \set{\pos_j} are all different and thus \set{\nf_j}
are independent values of the random oracle \NF at distinct inputs).
$\sig_1,\ldots,\sig_\ell$ are independent from each other, depend on \inps and the inner randomness of the signer.


$\inp_j$ has the form
\[\inp_j = (\nf,\rt,\rk,\cv,\prf)\]

  

the signature \sigval: can be simulating by a signing oracle except w.p. \negl (get's ruined if \RO was already queried on point)
the signatures \sigs: same.
\end{proof}
\subsection{Balance}
The following claim states an adversary should not be able to create ``money out of thin air'';
or more specifically, extract more money from the shielded pool than was put in it.
In Sapling, the value $\vbal=\vbal(\tx)$ in a transaction \tx corresponds to the alleged difference of spend and output values (see Section 4.12 in the spec) and \tx is thought of as having  ;
thus over-extracting from the pool corresponds to a constructing a ledger where the sum of all \vbal values is strictly positive.
\begin{claim}\label{clm:balance-sapling}
 The probability that an efficient \adv generates ledger $\ledger=(\tx_1,\ldots,\tx_n)$ such that
 \[\sum_{\tx\in \ledger} \vbal(\tx) >0 \]
 is \negl.
\end{claim}

 \begin{proof}
 Given \adv that produces a ledger as in the claim statement w.p. $\gamma$, we construct an efficient \adv' that
 w.p $\gamma/2-\negl$ produces a collision of \IVK,\notecom,\treehash or \valcom.
 It follows that $\gamma =\negl$.
\begin{enumerate}
\item \adv' begins by running \adv and aborting if \adv hasn't output a ledger as in the claim.
\item Otherwise, given such a ledger \ledger, \adv' can apply an extractor for each SNARK proof in all inputs and ouputs in all transactions.
 For each transaction input $\inp\in \tx\in \ledger$, $\inp=(\cv,\nf,\rt,\rk,\pi)$, the extractor except w.p. \negl 
 outputs an input witness $\inpwitness = (\input=(\note,\path,\pos),\pak,\rcv,\alpha))$.
 We denote by $\posnote$ the \emph{positioned note} corresponding to \inp, $\posnote \defeq (\note,\pos)$.
 Similarly for every transaction output in some \tx in \ledger, $\out = (\cv,\cm,\epk,\pi,\noteenc)$,
 the extractor outputs $\outwitness= (\note,\esk,\rcv)$. The value \pos for the output note can be deduced from when it was added to \ledger,
 i.e., the location of \cm in the commitment tree.
 So again we can define for each \out, the corresponding positioned note $\posnote = (\note,\pos)$.
For $i\in [n]$ let us denote respectively by $\inpnotes_i,\outnotes_i$ the positioned input and output notes in $\tx_i$ \emph{with non-zero value}\footnote{Sapling enables the creation of dummy notes with zero value, for which the spend statement doesn't check Merkle path validity, cf. Section 4.7.2 in the spec).}.


We also use the extractor from theorem \ref{thm:extractSchnorr} to find $s$ such that $S=s\cdot \gr$
where
\[S\defeq\sum_{i=1}^\ell \cv_i - \sum_{i=\ell+1}^{\ell+s}\cv_i-\vbal\cdot \gv\]
is the public key in the value binding signature \sigval.

If one of the extractor runs fails \adv' aborts. Note that w.p. at least $\gamma/2 -\negl$ \adv' doesn't abort.

\item  \adv' checks if for some $i\in [n]$ and $\inp\in \tx_i, \posnote(\inp)\notin \outnotes_{<i}$.

If so, let $\tx=\tx_i$. Let \rt be the root of the tree used in the public input of \inp; this is the tree $T_j$ formed from $\set{\tx_1,\ldots,\tx_j}$ for some $j<i$.
Let $\posnote=(\gd,\pk,\val,\rcm,\pos)$ and $\cm=\notecom(\gd,\pk,\val,\rcm)$.
\inpwitness contains a path $\path$ from \cm to \rt.
If \pos is an index of a leaf in $T_j$, there exists an extended note $\posnote'$ that was inserted to this position when constructing the ledger
and from \posnote' we can derive a path \path' from $\cm' = \notecom(\gd',\pk',\val',\rcm')$ in position \pos to \rt.
If $\path\neq\path'$, then going down from \rt to the first difference between \path and \path'
(ask Sean/Daira : is $T$ always a full tree with zeroes on other leaves? No you have filler values for the empty subtrees, need to check this are values that are hard to find route to - their impossible to find rout to - have no preimage)
%Assuming \path' always exists (the zero-padding option)
this difference gives a collision of \treehash that \adv' can output.


Otherwise, we have $\cm=\cm'$.
\note must be different from \note' because $\posnote' = (\note',\pos)\in \outnotes_{<i}$ but $(\note,\pos)\notin \outnotes_{<i}$.

Thus $\note,\note'$ is a collision of \notecom. In this case, \adv' outputs this collision and terminates.


Now suppose \pos is not a position of a leaf in $T_j$. This means there is only a partial path \path' in $T_j$ from \rt to a filler value with no preimage (see spec for details).
So, similarly we follow \path and \path' to their first difference - a difference that must exist becaues of the filler value; and this gives us a collision of \treehash that \adv' outputs.





\item Now \adv' checks if as a multiset $\inpnotes \defeq \inpnotes_1\cup\ldots\cup\inpnotes_n$ contains a repetition.
That is, there exists $\posnote= (\gd,\pk,\val,\rcm,\pos)$ such that for two distinct transaction inputs $\inp = (\cv,\nf,\rt,\rk,\pi), \inp'=(\cv',\nf',\rt',\rk',\pi')$ in \ledger;
if the corresponding extracted witnesses are $\inpwitness = (\input=(\note,\path,\pos),\pak,\rcv,\alpha)$,
$\inpwitness' = (\input'=(\note',\path',\pos'),\pak',\rcv',\alpha')$; then $(\note,\pos) = (\note',\pos') = \posnote$.


We show in this case that \adv' can output a collision of \IVK:


Let $\cm=\notecom(\gd,\pk,\val,\rcm)$.
Since $\nf\neq \nf'$,
and 
$\nf = \NF(\nk,\cm,\pos),\nf'= \NF(\nk',\cm,\pos)$;
we have  $\nk \neq\nk'$.

Also $\ivk = \IVK(\ak,\nk), \ivk'=\IVK(\ak',\nk')$,
and $\pk=\ivk\cdot \gd = \ivk'\cdot \gd$.
So $\ivk=\ivk'$ (Check with Sean is ivk canonical - checked)
And thus, \adv' can output $(\ak,\nk),(\ak',\nk')$ as a collision of \IVK.


\item Let us denote by $\bal(\tx)$ the (integer) sum of values in inputs of \tx minus the sum of values in output of \tx (notes meaning those output by the extractors);
and by $\rand(\tx)$ the sum of values $\rcv$ in input witnesses of \tx minus the sum of values \rcv in output witnesses of \tx.
When reaching this point with no output we know that:

For each $i\in [n], \inpnotes_i \subset \outnotes_1\cup\ldots\cup\outnotes_{i-1}\setminus(\inpnotes_1\cup\ldots\cup\inpnotes_{i-1})$.

This implies 
\[\sum_{\tx\in\ledger} \bal(\tx) \leq 0.\]

We claim that we must have for some $\tx\in\ledger$, $\bal(\tx)\neq \vbal(\tx)$:
Otherwise, we would have
\[\sum_{\tx\in \ledger} \vbal(\tx) = \sum_{\tx\in\ledger} \bal(\tx) \leq 0,\]

contradicting the fact that \adv has mannaged to output \ledger with a positive sum of $\vbal$ values.

Thus, let $\tx=\tx_i$ be such that $\bal(\tx)\neq\vbal(\tx)$. We show in the next step how \adv' uses this to output a collision of \valcom.

\item At this point, we know that $\bal(\tx) \neq \vbal(\tx)$. As both these values are in the open interval \footnote{See 
the spec for details: \vbal and \val in each transaction input/output are at most $2^{64}$ in absolute value, so assuming 
less than, e.g., $2^{r-66}$ transaction inputs and outputs in any transaction, this is true.} $(-r/2,r/2)$, we have also $\bal(\tx)\neq \vbal(\tx)$ $(\mathrm{mod}\;  r)$.
Suppose we are in this case with probability $\gamma$. We show how to find a collision of \valcom with probability
$\gamma/\poly$. Since \tx verifies, we know that
$\versig^{\RO}_{\gr}(S,\sighash(\rawtx),\sigval)$ for 
\[S=\sum_{i=1}^\ell \cv_i - \sum_{i=\ell+1}^{\ell+s}\cv_i-\vbal\cdot \gv= \left(\sum_{i=1}^{\ell} \val_i-\sum_{i=\ell+1}^{s} \val_i\right)\cdot \gv + \left(\sum_{i=1}^{\ell} \rcv_i-\sum_{i=\ell+1}^{s} \rcv_i\right)\cdot \gr  - \vbal\cdot \gv.\]
Using Theorem \ref{thm:extractSchnorr}, we can
with probability $\gamma/2$ we can use the forking lemma to rewind \adv while altering the response of \RO on the signature challenge in \sigval, and find $s$ such that $s\cdot \gr = S$.
Thus, we have $\valcom(0,s) = S$.

Let $R\defeq \sum_{i=1}^{\ell} \rcv_i-\sum_{i=\ell+1}^{s} \rcv_i$  and $v\defeq \bal(\tx)-\vbal(\tx)$.
We also have $\valcom(v,R) = S$.
Hence $\adv'$ can output $(0,s), (v,R)$ as a collision of \valcom.

\end{enumerate}

 \end{proof}
 
\subsection{Spendability}

\paragraph{Valid transaction bases:}
A sequence $\txinput = (\inputs,\outputs,\vbal)$ is
a \emph{valid transaction base} if $\vbal =  \sum \val(\input_i) - \sum \val(\output_j)$.

We review note encryption and decryption from the spec in our notation.

% \paragraph{Encrypting notes:}
% Given $\note=(\gd,\pk,\val,\rcm)$ and outgoing viewing key \ovk.
% \begin{enumerate}
%  \item Choose random $\esk\in \F$ and let $\epk\def \esk\cdot g$.
%  \item Let $\secret \defeq \esk\cdot \pk$.
%  \item Let $\notenc = \symencrypt{\secret}{\note}$
% \end{enumerate}



\paragraph{Decrypting notes:\\}
\noindent
$\underline{\dec(\ivk,\out=(\cv,\cm,\epk,\prf,\noteenc))}$
\begin{enumerate}
\item Let $K\defeq \KDF(\epk\cdot \ivk)$
 \item Let $\np=\symdecrypt{K}{\noteenc}$. If \symdecrypt{}{} fails output \rej.
 \item Suppose $\np=(\d,\val,\rcm,\mathsf{memo})$. If $\rcm\geq r$ output \rej. 
\item Let $\gd\defeq \ghash(\d)$.
 \item Let $\pk\defeq \gd\cdot \ivk$. Let $\note\defeq (\gd,\pk,\val,\rcm)$.
 \item Check that $\cm=\notecom(\note)$. Output \rej if not.
 \item Output \note.
\end{enumerate}
We define 
\[\dec(\ivk,\tx) \defeq \cup_{\out\in\tx} \dec(\ivk,\out),\]
\[\dec(\ivk,\ledger) \defeq \cup_{\tx\in\ledger} \dec(\ivk,\tx)\]
And also
\[\nfof{\tx} \defeq \cup_{\inp\in\inps(\tx)}\nfof{\inp},\nfof{\ledger}\defeq\cup_{\tx\in\ledger}\nfof{\tx}\]
%We consider an adversary \adv that has access to \signallinputs queries of \oracle, identically to the non-malleability section.
% \adv receives a challenge $\pak = (\ak,\nsk)$ where $\nsk\in \F,\ak\in \G$ were chosen uniformly.
% Let $\ivk\defeq \IVK(\pak)$.
In the spendability game \adv tries to create a ledger where a note succesfully decrypted with \ivk cannot be spent.
Formally, the game proceeds as follows.
\begin{enumerate}
 \item We choose uniform $\sk = (\ask,\nsk)$; and give $\pak=(\ask\cdot \gsig, \nsk)$ to \adv.
\item \adv outputs a ledger \ledger, a positioned note $(\note,\pos)$, a set of output notes \outputs, and
a set of incoming viewing keys \ivks. 
\item We choose random $\rcvs\in \F^{\ell+s}$ and compute $\tx = \maketx(\inputs,\outputs,\vbal,\ask)$.
\item Let $\ivk \defeq \IVK(\ak,\nk)$. \adv wins iff 
\begin{enumerate}
\item $\note \in \dec(\ivk,\ledger)$.
\item  $((\note),\outputs,\vbal)$ is a valid transaction base.
\item For each $i\in [s]$, $\output_i$ belongs to $\ivk_i$.
 \item $\verifytx{\ledger}{\tx}$.
 \item For some $i\in [s]$, $\dec(\ivk_i,\out_i)$ does not return $\output_i$.
\end{enumerate}
\end{enumerate}

We wish to show that the success of any efficient \adv in this game is \negl.


Let $\nk =\nsk\cdot\gnk$.
Inspection of the protocol shows this exactly corresponds to the nullifer of \note with nullifer key \nk already appearing in the ledger.
Thus, it suffices to prove the following.
\begin{claim}\label{sapling-spendability}
 Fix any efficient \adv.
 Suppose that \adv  is given uniformly chosen \pak, and let $\ivk \defeq \IVK(\pak)$.
The probability that \adv generates a ledger \ledger and positoned note (\note,\pos) such that 
 \begin{enumerate}
  \item $(\note,\pos)\in \dec(\ivk,\ledger)$
  \item $\NF(\nk,\notecom(\note),\pos)\in \nfof{\ledger}$ 
 \end{enumerate}
 is \negl.
\end{claim}
\begin{proof}
Let $\gamma$ be the probability that \adv outputs $\ledger,\note$ satisfying the two properties in the claim.
We construct an efficient \advprime that receives a forgery challenge \ak of \schnorr and w.p. $\gamma-\negl$ does one of the following.
\begin{itemize}
\item Output a collision of either \NF, \notecom or \IVK.
 \item Output a forgery w.r.t to randomization of \schnorr for the challenge \ak.
\end{itemize}


\advprime works as follows.

 \begin{enumerate}
  \item  \advprime receives a challenge \ak; chooses random $\nsk\in \F$ and sends $\pak=(\ak,\nsk)$ to \adv.
\item \advprime receives the output $(\ledger,\note,\pos)$ of \adv.
\item \advprime checks that $\ledger,(\note,\pos)$ satisfy the two properties in the claim; if not it aborts.
\item  Let $\nf \defeq \NF(\nk,\notecom(\note),\pos)$.
Fix the $\out,\tx$ with $\out\in\tx\in \ledger$ such that $\dec(\ivk,\out) = (\note,\pos)$.
\out contains a valid SNARK proof for \spendstatement{\rt,\cv,\nf,\rk} for some $\cv,\rt$.
Apply the relevant extractor \ext relating to the snark proof to
obtain e.w.p \negl a witness $\path,\pos',\gd',\pk',\val',\rcm',\cm',\rcv',\alpha,\ak',\nsk'$ for the statement.
\item Let $\nk' \defeq \nsk'\cdot \gnk$. If $(\nk,\cm,\pos)\neq (\nk',\cm',\pos')$, \advprime outputs $(\nk,\cm,\pos),(\nk',\cm',\pos')$ as a collision of \NF.
\item Otherwise, let $\note' = (\gd',\pk',\val',\rcm')$. We have $\cm=\notecom(\note)=\notecom(\note')$. If $(\gd',\pk',\val')\neq (\gd,\pk,\val)$, \advprime outputs $(\note,\note')$ as a collision of \notecom.
\item Otherwise, we must have $\ivk'=\ivk$ (cause $\gd\cdot \ivk = \gd \cdot \ivk' = \pk$). Then $\ivk = \IVK(\ak',\nk)$ (by this stage we know $\nk=\nk'$).
If $\ak\neq \ak'$, \advprime outputs $(\ak,\nk),  (\ak',\nk)$ as a collision of \IVK.
\item Otherwise $\ak=\ak'$, and $\rk = \ak + \alpha \cdot \g$. Let $\sigma$ be the signature of \rawtx with public key \rk in \inp.
and \advprime outputs $(\alpha, \rawtx, \sig)$ as a forgery of \schnorr with challenge \ak.
 \end{enumerate}

 
 
\end{proof}



\begin{remark}
 Note that in the spendability and non-malleability property \adv can choose what value \nf to work with.
 It seems likely that in a weaker model where the values \nf 
\end{remark}





% 
% ----------SECOND  ATEMPT-------------------
% 
% \adv interacts with \oracle by maketx queries and createaddr queries,
% can also insert txs to ledger.
% Keeps track of inputs not used yet.
% 
% 
% Del Spender in spendability game:
% List of unspent notes.
% Makes $\signallinputs(\tx)$ queries.
% These make $\nf(\tx)$ crossed off - actually what crossed off? Have \inp, not \input.
% Can add to ledger \ledger any valid \tx.
% $\decode_{\sk}(\tx)$ added to \curnotes.
% 
% 
% 
% % \subsection{Uniqueness}
% How to define?
% 
% 1 - Interact with honest player, either inserting tx to ledger, or 
% give them inputs and outputs, with inputs in their create address output.
% % honest decodes at the end of each transaction, 
% 
% output ledger, legal transaction input \txinput where \inputs
% are coins of honest player  that haven't been used.
% Such that \createtx{\ledger}{\txinput}
% fails (with some probability? with noticeable prob?)
% 
% is \negl.


\subsection{Indistinguishability of diversifed addresses}


El-gammal encryption
private key \sk
public key $[\sk]\cdot \g$
encryption of $x$: [\sk]
\bibliography{refs}
\bibliographystyle{plain}
\end{document}



























